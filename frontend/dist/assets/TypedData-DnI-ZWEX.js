import{aM as G,b7 as U,b8 as J,b9 as f,ba as D,bb as y,b2 as h,aP as m,bc as w,bd as O,be as K,bf as x,bg as T,b5 as q,bh as j}from"./index-anYD-FGg.js";import{i as S,b as L,a as Q}from"./parse-typed-data-B5i2uSeh.js";class X extends Map{constructor(t){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=t}get(t){const n=super.get(t);return super.has(t)&&n!==void 0&&(this.delete(t),super.set(t,n)),n}set(t,n){if(super.set(t,n),this.maxSize&&this.size>this.maxSize){const r=this.keys().next().value;r&&this.delete(r)}return this}}const Y={checksum:new X(8192)},P=Y.checksum;function l(e,t={}){const{as:n=typeof e=="string"?"Hex":"Bytes"}=t,r=G(U(e));return n==="Bytes"?r:J(r)}const Z=/^0x[a-fA-F0-9]{40}$/;function E(e,t={}){const{strict:n=!0}=t;if(!Z.test(e))throw new $({address:e,cause:new k});if(n){if(e.toLowerCase()===e)return;if(ee(e)!==e)throw new $({address:e,cause:new re})}}function ee(e){if(P.has(e))return P.get(e);E(e,{strict:!1});const t=e.substring(2).toLowerCase(),n=l(D(t),{as:"Bytes"}),r=t.split("");for(let a=0;a<40;a+=2)n[a>>1]>>4>=8&&r[a]&&(r[a]=r[a].toUpperCase()),(n[a>>1]&15)>=8&&r[a+1]&&(r[a+1]=r[a+1].toUpperCase());const s=`0x${r.join("")}`;return P.set(e,s),s}function te(e,t={}){const{strict:n=!0}=t??{};try{return E(e,{strict:n}),!0}catch{return!1}}class $ extends f{constructor({address:t,cause:n}){super(`Address "${t}" is invalid.`,{cause:n}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidAddressError"})}}class k extends f{constructor(){super("Address is not a 20 byte (40 hexadecimal character) value."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidInputError"})}}class re extends f{constructor(){super("Address does not match its checksum counterpart."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"Address.InvalidChecksumError"})}}function ne({checksumAddress:e,parameters:t,values:n}){const r=[];for(let s=0;s<t.length;s++)r.push(A({checksumAddress:e,parameter:t[s],value:n[s]}));return r}function A({checksumAddress:e=!1,parameter:t,value:n}){const r=t,s=de(r.type);if(s){const[a,i]=s;return ae(n,{checksumAddress:e,length:a,parameter:{...r,type:i}})}if(r.type==="tuple")return pe(n,{checksumAddress:e,parameter:r});if(r.type==="address")return se(n,{checksum:e});if(r.type==="bool")return oe(n);if(r.type.startsWith("uint")||r.type.startsWith("int")){const a=r.type.startsWith("int"),[,,i="256"]=S.exec(r.type)??[];return ce(n,{signed:a,size:Number(i)})}if(r.type.startsWith("bytes"))return ie(n,{type:r.type});if(r.type==="string")return ue(n);throw new _(r.type)}function v(e){let t=0;for(let a=0;a<e.length;a++){const{dynamic:i,encoded:o}=e[a];i?t+=32:t+=y(o)}const n=[],r=[];let s=0;for(let a=0;a<e.length;a++){const{dynamic:i,encoded:o}=e[a];i?(n.push(h(t+s,{size:32})),r.push(o),s+=y(o)):n.push(o)}return m(...n,...r)}function se(e,t){const{checksum:n=!1}=t;return E(e,{strict:n}),{dynamic:!1,encoded:w(e.toLowerCase())}}function ae(e,t){const{checksumAddress:n,length:r,parameter:s}=t,a=r===null;if(!Array.isArray(e))throw new ye(e);if(!a&&e.length!==r)throw new fe({expectedLength:r,givenLength:e.length,type:`${s.type}[${r}]`});let i=!1;const o=[];for(let c=0;c<e.length;c++){const u=A({checksumAddress:n,parameter:s,value:e[c]});u.dynamic&&(i=!0),o.push(u)}if(a||i){const c=v(o);if(a){const u=h(o.length,{size:32});return{dynamic:!0,encoded:o.length>0?m(u,c):u}}if(i)return{dynamic:!0,encoded:c}}return{dynamic:!1,encoded:m(...o.map(({encoded:c})=>c))}}function ie(e,{type:t}){const[,n]=t.split("bytes"),r=y(e);if(!n){let s=e;return r%32!==0&&(s=x(s,Math.ceil((e.length-2)/2/32)*32)),{dynamic:!0,encoded:m(w(h(r,{size:32})),s)}}if(r!==Number.parseInt(n))throw new C({expectedSize:Number.parseInt(n),value:e});return{dynamic:!1,encoded:x(e)}}function oe(e){if(typeof e!="boolean")throw new f(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:w(O(e))}}function ce(e,{signed:t,size:n}){if(typeof n=="number"){const r=2n**(BigInt(n)-(t?1n:0n))-1n,s=t?-r-1n:0n;if(e>r||e<s)throw new K({max:r.toString(),min:s.toString(),signed:t,size:n/8,value:e.toString()})}return{dynamic:!1,encoded:h(e,{size:32,signed:t})}}function ue(e){const t=T(e),n=Math.ceil(y(t)/32),r=[];for(let s=0;s<n;s++)r.push(x(q(t,s*32,(s+1)*32)));return{dynamic:!0,encoded:m(x(h(y(t),{size:32})),...r)}}function pe(e,t){const{checksumAddress:n,parameter:r}=t;let s=!1;const a=[];for(let i=0;i<r.components.length;i++){const o=r.components[i],c=Array.isArray(e)?i:o.name,u=A({checksumAddress:n,parameter:o,value:e[c]});a.push(u),u.dynamic&&(s=!0)}return{dynamic:s,encoded:s?v(a):m(...a.map(({encoded:i})=>i))}}function de(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}function B(e,t,n){const{checksumAddress:r=!1}={};if(e.length!==t.length)throw new N({expectedLength:e.length,givenLength:t.length});const s=ne({checksumAddress:r,parameters:e,values:t}),a=v(s);return a.length===0?"0x":a}function z(e,t){if(e.length!==t.length)throw new N({expectedLength:e.length,givenLength:t.length});const n=[];for(let r=0;r<e.length;r++){const s=e[r],a=t[r];n.push(z.encode(s,a))}return m(...n)}(function(e){function t(n,r,s=!1){if(n==="address"){const c=r;return E(c),w(c.toLowerCase(),s?32:0)}if(n==="string")return T(r);if(n==="bytes")return r;if(n==="bool")return w(O(r),s?32:1);const a=n.match(S);if(a){const[c,u,d="256"]=a,p=Number.parseInt(d)/8;return h(r,{size:s?32:p,signed:u==="int"})}const i=n.match(L);if(i){const[c,u]=i;if(Number.parseInt(u)!==(r.length-2)/2)throw new C({expectedSize:Number.parseInt(u),value:r});return x(r,s?32:0)}const o=n.match(Q);if(o&&Array.isArray(r)){const[c,u]=o,d=[];for(let p=0;p<r.length;p++)d.push(t(u,r[p],!0));return d.length===0?"0x":m(...d)}throw new _(n)}e.encode=t})(z||(z={}));class fe extends f{constructor({expectedLength:t,givenLength:n,type:r}){super(`Array length mismatch for type \`${r}\`. Expected: \`${t}\`. Given: \`${n}\`.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.ArrayLengthMismatchError"})}}let C=class extends f{constructor({expectedSize:t,value:n}){super(`Size of bytes "${n}" (bytes${y(n)}) does not match expected size (bytes${t}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.BytesSizeMismatchError"})}};class N extends f{constructor({expectedLength:t,givenLength:n}){super(["ABI encoding parameters/values length mismatch.",`Expected length (parameters): ${t}`,`Given length (values): ${n}`].join(`
`)),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.LengthMismatchError"})}}class ye extends f{constructor(t){super(`Value \`${t}\` is not a valid array.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidArrayError"})}}class _ extends f{constructor(t){super(`Type \`${t}\` is not a valid ABI Type.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiParameters.InvalidTypeError"})}}function me(e){const{domain:t,message:n,primaryType:r,types:s}=e,a=(i,o)=>{for(const c of i){const{name:u,type:d}=c,p=o[u],b=d.match(S);if(b&&(typeof p=="number"||typeof p=="bigint")){const[,g,F]=b;h(p,{signed:g==="int",size:Number.parseInt(F??"")/8})}if(d==="address"&&typeof p=="string"&&!te(p))throw new $({address:p,cause:new k});const I=d.match(L);if(I){const[,g]=I;if(g&&y(p)!==Number.parseInt(g))throw new be({expectedSize:Number.parseInt(g),givenSize:y(p)})}const M=s[d];M&&(Ee(d),a(M,p))}};if(s.EIP712Domain&&t){if(typeof t!="object")throw new ge({domain:t});a(s.EIP712Domain,t)}if(r!=="EIP712Domain")if(s[r])a(s[r],n);else throw new we({primaryType:r,types:s})}function le(e){const{primaryType:t,types:n}=e;let r="";const s=V({primaryType:t,types:n});s.delete(t);const a=[t,...Array.from(s).sort()];for(const i of a)r+=`${i}(${(n[i]??[]).map(({name:o,type:c})=>`${c} ${o}`).join(",")})`;return r}function R(e){return[typeof(e==null?void 0:e.name)=="string"&&{name:"name",type:"string"},(e==null?void 0:e.version)&&{name:"version",type:"string"},typeof(e==null?void 0:e.chainId)=="number"&&{name:"chainId",type:"uint256"},(e==null?void 0:e.verifyingContract)&&{name:"verifyingContract",type:"address"},(e==null?void 0:e.salt)&&{name:"salt",type:"bytes32"}].filter(Boolean)}function Te(e){const{domain:t,types:n}=e;return he({data:t,primaryType:"EIP712Domain",types:{...n,EIP712Domain:(n==null?void 0:n.EIP712Domain)||R(t)}})}function he(e){const{data:t,primaryType:n,types:r}=e,s=W({data:t,primaryType:n,types:r});return l(s)}function Se(e){const{domain:t,message:n,primaryType:r,types:s}=e,a=(c,u)=>{const d={...u};for(const p of c){const{name:b,type:I}=p;I==="address"&&(d[b]=d[b].toLowerCase())}return d},i=(()=>{if(!t)return{};const c=s.EIP712Domain??R(t);return a(c,t)})(),o=(()=>{if(r!=="EIP712Domain")return s[r]?a(s[r],n):{}})();return j({domain:i,message:o,primaryType:r,types:s},(c,u)=>typeof u=="bigint"?u.toString():u)}function Ae(e){try{return me(e),!0}catch{return!1}}class be extends f{constructor({expectedSize:t,givenSize:n}){super(`Expected bytes${t}, got bytes${n}.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TypedData.BytesSizeMismatchError"})}}class ge extends f{constructor({domain:t}){super(`Invalid domain "${j(t)}".`,{metaMessages:["Must be a valid EIP-712 domain."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TypedData.InvalidDomainError"})}}class we extends f{constructor({primaryType:t,types:n}){super(`Invalid primary type \`${t}\` must be one of \`${JSON.stringify(Object.keys(n))}\`.`,{metaMessages:["Check that the primary type is a key in `types`."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TypedData.InvalidPrimaryTypeError"})}}class xe extends f{constructor({type:t}){super(`Struct type "${t}" is invalid.`,{metaMessages:["Struct type must not be a Solidity type."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TypedData.InvalidStructTypeError"})}}function W(e){const{data:t,primaryType:n,types:r}=e,s=[{type:"bytes32"}],a=[Ie({primaryType:n,types:r})];for(const i of r[n]??[]){const[o,c]=H({types:r,name:i.name,type:i.type,value:t[i.name]});s.push(o),a.push(c)}return B(s,a)}function Ie(e){const{primaryType:t,types:n}=e,r=T(le({primaryType:t,types:n}));return l(r)}function H(e){let{types:t,name:n,type:r,value:s}=e;if(t[r]!==void 0)return[{type:"bytes32"},l(W({data:s,primaryType:r,types:t}))];if(r==="bytes")return s=`0x${(s.length%2?"0":"")+s.slice(2)}`,[{type:"bytes32"},l(s,{as:"Hex"})];if(r==="string")return[{type:"bytes32"},l(D(s),{as:"Hex"})];if(r.lastIndexOf("]")===r.length-1){const a=r.slice(0,r.lastIndexOf("[")),i=s.map(o=>H({name:n,type:a,types:t,value:o}));return[{type:"bytes32"},l(B(i.map(([o])=>o),i.map(([,o])=>o)))]}return[{type:r},s]}function V(e,t=new Set){const{primaryType:n,types:r}=e,s=n.match(/^\w*/u),a=s==null?void 0:s[0];if(t.has(a)||r[a]===void 0)return t;t.add(a);for(const i of r[a])V({primaryType:i.type,types:r},t);return t}function Ee(e){if(e==="address"||e==="bool"||e==="string"||e.startsWith("bytes")||e.startsWith("uint")||e.startsWith("int"))throw new xe({type:e})}export{te as a,B as b,R as e,Te as h,l as k,Se as s,Ae as v};
